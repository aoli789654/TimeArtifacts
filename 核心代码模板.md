# 《时光信物》核心代码模板

## 1. 游戏状态接口 (include/core/GameState.h)
```cpp
#pragma once
#include <string>

/**
 * 游戏状态基类接口
 * 所有具体的游戏状态都必须继承此类
 */
class GameState {
public:
    virtual ~GameState() = default;
    
    // 进入状态时调用
    virtual void enter() = 0;
    
    // 处理用户输入
    virtual void handleInput(const std::string& input) = 0;
    
    // 更新游戏逻辑
    virtual void update(float deltaTime) = 0;
    
    // 渲染界面
    virtual void render() = 0;
    
    // 退出状态时调用
    virtual void exit() = 0;
    
    // 获取状态名称
    virtual std::string getName() const = 0;
};
```

## 2. 事件系统 (src/core/Events.h)
```cpp
#pragma once
#include <string>
#include <memory>

/**
 * 事件基类
 */
class Event {
public:
    virtual ~Event() = default;
    virtual std::string getType() const = 0;
};

// 属性变化事件
class AttributeChangedEvent : public Event {
public:
    std::string attributeName;
    int oldValue;
    int newValue;
    
    AttributeChangedEvent(const std::string& name, int old_val, int new_val)
        : attributeName(name), oldValue(old_val), newValue(new_val) {}
    
    std::string getType() const override { return "AttributeChanged"; }
};

// 物品获得事件
class ItemAcquiredEvent : public Event {
public:
    std::string itemId;
    std::string itemName;
    
    ItemAcquiredEvent(const std::string& id, const std::string& name)
        : itemId(id), itemName(name) {}
    
    std::string getType() const override { return "ItemAcquired"; }
};

// 场景切换事件
class LocationChangedEvent : public Event {
public:
    std::string fromLocation;
    std::string toLocation;
    
    LocationChangedEvent(const std::string& from, const std::string& to)
        : fromLocation(from), toLocation(to) {}
    
    std::string getType() const override { return "LocationChanged"; }
};

// 洞察获得事件
class InsightGainedEvent : public Event {
public:
    std::string insightId;
    std::string description;
    
    InsightGainedEvent(const std::string& id, const std::string& desc)
        : insightId(id), description(desc) {}
    
    std::string getType() const override { return "InsightGained"; }
};
```

## 3. 通用类型定义 (include/common/Types.h)
```cpp
#pragma once
#include <string>
#include <vector>
#include <memory>
#include <unordered_map>
#include <set>

// 基础类型别名
using ItemID = std::string;
using LocationID = std::string;
using CharacterID = std::string;
using InsightID = std::string;
using AttributeID = std::string;

// 属性类型枚举
enum class AttributeType {
    OBSERVATION,    // 观察力
    COMMUNICATION, // 沟通力
    ACTION,        // 行动力
    EMPATHY        // 共情值
};

// 物品类型枚举
enum class ItemType {
    MEMENTO,       // 时光信物
    CLUE,          // 线索物品
    STORY          // 故事物品
};

// 游戏状态枚举
enum class GameStateType {
    MAIN_MENU,
    EXPLORING,
    DIALOGUE,
    JOURNAL,
    PUZZLE,
    PAUSE_MENU
};

// 前向声明
class Item;
class Location;
class Character;
class Player;

// 智能指针类型别名
using ItemPtr = std::unique_ptr<Item>;
using LocationPtr = std::unique_ptr<Location>;
using CharacterPtr = std::unique_ptr<Character>;
```

## 4. 玩家类框架 (src/gameplay/Player.h)
```cpp
#pragma once
#include "common/Types.h"
#include "Inventory.h"
#include "Attribute.h"
#include <set>
#include <unordered_map>

/**
 * 玩家类 - 游戏系统开发者负责实现
 */
class Player {
private:
    std::string name;
    LocationID currentLocation;
    
    // 属性系统
    std::unordered_map<AttributeType, int> attributes;
    
    // 洞察系统
    std::set<InsightID> insights;
    
    // 物品栏
    std::unique_ptr<Inventory> inventory;
    
    // 已完成的任务/标记
    std::set<std::string> completedQuests;
    std::set<std::string> storyFlags;

public:
    Player(const std::string& playerName);
    ~Player() = default;
    
    // 基础信息
    const std::string& getName() const { return name; }
    const LocationID& getCurrentLocation() const { return currentLocation; }
    void setCurrentLocation(const LocationID& locationId);
    
    // 属性系统
    int getAttribute(AttributeType type) const;
    void setAttribute(AttributeType type, int value);
    void addAttribute(AttributeType type, int delta);
    bool hasAttributeThreshold(AttributeType type, int threshold) const;
    
    // 洞察系统
    void addInsight(const InsightID& insightId);
    bool hasInsight(const InsightID& insightId) const;
    const std::set<InsightID>& getAllInsights() const { return insights; }
    
    // 物品栏操作
    bool addItem(ItemPtr item);
    bool removeItem(const ItemID& itemId);
    bool hasItem(const ItemID& itemId) const;
    Item* getItem(const ItemID& itemId) const;
    
    // 任务和标记
    void completeQuest(const std::string& questId);
    bool isQuestCompleted(const std::string& questId) const;
    void setStoryFlag(const std::string& flag);
    bool hasStoryFlag(const std::string& flag) const;
    
    // 存档相关
    void saveToJson(nlohmann::json& json) const;
    void loadFromJson(const nlohmann::json& json);
};
```

## 5. JSON数据结构示例

### locations.json (UI工程师负责设计)
```json
{
    "locations": {
        "time_corner_bookstore": {
            "name": "时光角落书店",
            "descriptions": {
                "default": "这是一家温馨的旧书店，书架上摆满了各个年代的书籍。阳光透过窗户洒在木制地板上，空气中弥漫着纸张的香味。",
                "evening": "夜幕降临，书店内亮起了暖黄色的灯光。在这样的氛围中，整个空间显得更加宁静而神秘。",
                "rainy": "雨点轻敲着书店的窗户，店内显得格外安静。你能听到远处传来的雨声，为这个空间增添了一丝诗意。"
            },
            "exits": {
                "north": "old_street",
                "east": "small_courtyard"
            },
            "items": ["old_diary", "dusty_photo"],
            "characters": ["bookstore_owner"],
            "interactions": [
                {
                    "id": "examine_bookshelf",
                    "name": "检查书架",
                    "description": "仔细查看书架上的书籍",
                    "requirements": {
                        "attribute": "observation",
                        "threshold": 2
                    },
                    "results": {
                        "text": "在书架的角落，你发现了一本看起来很特别的日记...",
                        "items": ["hidden_diary"],
                        "insights": ["bookstore_secret"]
                    }
                }
            ]
        }
    }
}
```

### dialogues.json (UI工程师负责设计)
```json
{
    "dialogues": {
        "bookstore_owner_first_meeting": {
            "speaker": "书店老板",
            "text": "欢迎来到时光角落，年轻人。你看起来像是在寻找什么特别的东西。",
            "options": [
                {
                    "text": "我在寻找一些旧物件，关于这个城市过去的记忆。",
                    "requirements": {},
                    "results": {
                        "dialogue": "bookstore_owner_about_memories",
                        "attributes": {
                            "communication": 1
                        }
                    }
                },
                {
                    "text": "[观察] 注意到他眼中的忧伤。",
                    "requirements": {
                        "attribute": "observation",
                        "threshold": 3
                    },
                    "results": {
                        "dialogue": "bookstore_owner_personal_story",
                        "insights": ["owner_sadness"],
                        "attributes": {
                            "empathy": 2
                        }
                    }
                },
                {
                    "text": "只是随便看看。",
                    "requirements": {},
                    "results": {
                        "dialogue": "bookstore_owner_casual_response"
                    }
                }
            ]
        }
    }
}
```

## 6. 主程序框架 (src/main.cpp)
```cpp
#include "core/GameEngine.h"
#include <iostream>
#include <exception>

int main() {
    try {
        GameEngine engine;
        engine.initialize();
        engine.run();
        engine.shutdown();
        return 0;
    }
    catch (const std::exception& e) {
        std::cerr << "游戏运行时发生错误: " << e.what() << std::endl;
        return -1;
    }
    catch (...) {
        std::cerr << "发生未知错误" << std::endl;
        return -1;
    }
}
```

## 7. 构建和运行说明

### 构建步骤
```bash
# 1. 安装vcpkg依赖
vcpkg install fmt nlohmann-json sfml

# 2. 创建构建目录
mkdir build
cd build

# 3. 配置CMake
cmake .. -DCMAKE_TOOLCHAIN_FILE=[vcpkg路径]/scripts/buildsystems/vcpkg.cmake

# 4. 编译
cmake --build . --config Release

# 5. 运行
./TimeArtifacts  # Linux/Mac
TimeArtifacts.exe  # Windows
```

### 开发工作流
1. 每个人在自己的分支上开发
2. 每日合并到develop分支
3. 完成里程碑后合并到main分支
4. 使用Pull Request进行代码审查

这些模板为团队提供了：
- 清晰的接口定义
- 统一的代码风格
- 标准的数据格式
- 完整的构建流程

确保每个团队成员都理解这些接口，这是成功协作的关键。
