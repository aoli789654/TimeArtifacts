# 《时光信物》混合架构技术方案

## 🎯 架构概述

采用**C++后端 + Web前端**的混合架构，充分发挥两种技术栈的优势：
- **C++后端**：高性能游戏逻辑处理、数据管理、音频处理
- **Web前端**：现代化UI界面、丰富的视觉效果、跨平台兼容

---

## 🔧 技术栈详解

### 后端技术栈 (C++)
```cpp
// 核心框架
- C++17/20 标准
- nlohmann/json (JSON处理)
- websocketpp (WebSocket服务器) 🆕
- SFML Audio (音频处理)
- CMake (构建系统)

// 可选增强库
- crow/drogon (HTTP服务器，如需REST API)
- spdlog (日志系统)
```

### 前端技术栈 (Web)
```javascript
// 基础技术
- HTML5 + CSS3 + ES6+
- WebSocket API (实时通信)
- Canvas API (可选，用于特效)

// 现代化工具 (渐进式采用)
- Node.js (开发工具链)
- Vite/Webpack (打包工具)
- TypeScript (类型安全，可选)
- Tailwind CSS (样式框架，可选)

// UI增强库 (按需选择)
- anime.js (动画效果)
- typed.js (打字机效果)
- particles.js (背景粒子效果)
```

---

## 📡 通信机制设计

### 1. WebSocket实时通信
```javascript
// 前端 JavaScript
class GameClient {
    constructor() {
        this.ws = new WebSocket('ws://localhost:8080');
        this.setupEventHandlers();
    }
    
    setupEventHandlers() {
        this.ws.onmessage = (event) => {
            const message = JSON.parse(event.data);
            this.handleGameMessage(message);
        };
    }
    
    sendCommand(action, data) {
        const message = {
            type: 'command',
            action: action,
            data: data,
            timestamp: Date.now()
        };
        this.ws.send(JSON.stringify(message));
    }
}
```

```cpp
// 后端 C++
class WebSocketHandler {
private:
    GameEngine* gameEngine;
    
public:
    void onMessage(const std::string& message) {
        nlohmann::json jsonMsg = nlohmann::json::parse(message);
        
        if (jsonMsg["type"] == "command") {
            std::string action = jsonMsg["action"];
            auto data = jsonMsg["data"];
            
            // 转发给游戏引擎处理
            auto result = gameEngine->processCommand(action, data);
            
            // 发送响应
            sendResponse(result);
        }
    }
};
```

### 2. API消息格式规范
```json
{
    "messageTypes": {
        "gameState": {
            "type": "gameState",
            "data": {
                "currentLocation": "bookstore",
                "playerAttributes": {"observation": 3, "empathy": 2},
                "inventory": ["old_diary", "mysterious_key"],
                "availableActions": ["examine_bookshelf", "talk_to_owner"]
            }
        },
        "dialogue": {
            "type": "dialogue",
            "data": {
                "speaker": "书店老板",
                "text": "欢迎来到时光角落...",
                "options": [
                    {"id": "option1", "text": "询问关于旧书的事情"},
                    {"id": "option2", "text": "[观察] 注意到他眼中的忧伤"}
                ]
            }
        },
        "sceneUpdate": {
            "type": "sceneUpdate",
            "data": {
                "location": "bookstore",
                "description": "书店内亮起了暖黄色的灯光...",
                "ambientEffects": ["gentle_rain", "page_turning"],
                "musicTrack": "bookstore_evening"
            }
        }
    }
}
```

---

## 🎨 前端UI设计方案

### 1. 界面布局设计
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>时光信物</title>
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
    <div id="game-container">
        <!-- 主要故事区域 -->
        <div id="story-panel" class="panel">
            <div id="location-header"></div>
            <div id="scene-description"></div>
            <div id="story-content"></div>
        </div>
        
        <!-- 对话区域 -->
        <div id="dialogue-panel" class="panel">
            <div id="speaker-name"></div>
            <div id="dialogue-text"></div>
            <div id="dialogue-options"></div>
        </div>
        
        <!-- 状态信息栏 -->
        <div id="status-panel" class="panel">
            <div id="player-attributes"></div>
            <div id="inventory-summary"></div>
            <div id="current-location"></div>
        </div>
        
        <!-- 日记系统 -->
        <div id="journal-panel" class="panel hidden">
            <div id="journal-content"></div>
        </div>
    </div>
    
    <script src="js/main.js"></script>
</body>
</html>
```

### 2. CSS样式系统（支持主题切换）
```css
/* 主题变量 */
:root {
    --bg-primary: #1a1a1a;
    --bg-secondary: #2d2d2d;
    --text-primary: #e0e0e0;
    --text-secondary: #b0b0b0;
    --accent-color: #d4af37;
    --border-color: #404040;
}

/* 怀旧主题 */
[data-theme="vintage"] {
    --bg-primary: #2c1810;
    --bg-secondary: #3d241a;
    --text-primary: #f4e4c1;
    --text-secondary: #d4c4a0;
    --accent-color: #cd853f;
    --border-color: #5d4037;
}

/* 响应式设计 */
.panel {
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 1rem;
    margin: 0.5rem;
    color: var(--text-primary);
    font-family: 'Georgia', serif;
    line-height: 1.6;
}

#story-panel {
    flex: 2;
    overflow-y: auto;
    max-height: 60vh;
}

#dialogue-panel {
    flex: 1;
    min-height: 200px;
}

/* 打字机效果 */
.typewriter {
    overflow: hidden;
    border-right: 2px solid var(--accent-color);
    white-space: nowrap;
    animation: typing 2s steps(40) forwards,
               blink-caret 1s step-end infinite;
}

@keyframes typing {
    from { width: 0; }
    to { width: 100%; }
}

@keyframes blink-caret {
    from, to { border-color: transparent; }
    50% { border-color: var(--accent-color); }
}
```

### 3. JavaScript交互增强
```javascript
// 现代化UI管理器
class UIManager {
    constructor() {
        this.currentTheme = 'default';
        this.gameClient = new GameClient();
        this.setupEventListeners();
        this.initializeAnimations();
    }
    
    // 打字机效果显示文本
    async typewriterText(element, text, speed = 50) {
        element.innerHTML = '';
        element.classList.add('typewriter');
        
        for (let i = 0; i < text.length; i++) {
            element.innerHTML += text.charAt(i);
            await new Promise(resolve => setTimeout(resolve, speed));
        }
        
        element.classList.remove('typewriter');
    }
    
    // 主题切换
    switchTheme(themeName) {
        document.documentElement.setAttribute('data-theme', themeName);
        this.currentTheme = themeName;
        
        // 保存到本地存储
        localStorage.setItem('gameTheme', themeName);
    }
    
    // 场景过渡效果
    async transitionToScene(sceneData) {
        const storyPanel = document.getElementById('story-panel');
        
        // 淡出效果
        storyPanel.style.opacity = '0';
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // 更新内容
        await this.updateSceneContent(sceneData);
        
        // 淡入效果
        storyPanel.style.opacity = '1';
    }
    
    // 动态背景效果（可选）
    initializeParticleBackground() {
        // 使用particles.js创建诗意的背景粒子效果
        particlesJS('game-container', {
            particles: {
                number: { value: 50 },
                color: { value: '#d4af37' },
                opacity: { value: 0.3 },
                size: { value: 2 },
                move: {
                    speed: 1,
                    direction: 'top'
                }
            }
        });
    }
}
```

---

## 🚀 第一阶段实施计划（修订版）

### 第1周：基础架构搭建
- **后端架构师**：搭建WebSocket服务器，定义API规范
- **前端工程师**：创建基础HTML/CSS/JS结构，实现WebSocket客户端
- **游戏系统开发者**：设计玩家和物品类
- **音频工程师**：研究Web Audio API与SFML的协作方案

### 第2周：核心功能实现
- **后端架构师**：完成游戏状态机和事件系统
- **前端工程师**：实现UI状态管理和基础视觉效果
- **游戏系统开发者**：完成核心游戏逻辑
- **音频工程师**：实现音频管理系统

### 第3周：集成与优化
- **全员**：前后端集成测试
- **前端工程师**：优化用户体验，添加动画效果
- **音频工程师**：集成音效系统
- **演示准备**：完整功能演示

---

## 💡 技术优势

### 1. 开发效率提升
- **并行开发**：前后端团队可独立开发，提高效率
- **技能专业化**：每个人专注自己擅长的技术栈
- **现代化工具**：Web开发生态更成熟，调试和开发工具更丰富

### 2. 用户体验增强
- **视觉效果**：CSS动画、过渡效果、主题切换
- **交互体验**：响应式设计、现代化界面
- **跨平台兼容**：Web界面天然支持多平台

### 3. 可维护性
- **职责分离**：UI逻辑与游戏逻辑完全分离
- **技术栈成熟**：使用业界成熟的技术方案
- **易于扩展**：后续可轻松添加新功能

### 4. 学习价值
- **全栈开发经验**：前端+后端完整项目经验
- **现代化开发流程**：符合当前企业开发模式
- **作品集亮点**：技术栈现代化，更适合展示

---

## ⚠️ 风险管控

### 主要挑战
1. **学习曲线**：WebSocket通信、前后端协调
2. **调试复杂度**：涉及两个进程的调试
3. **部署复杂性**：需要同时运行前后端

### 应对策略
1. **简化通信**：使用标准JSON格式，清晰的API文档
2. **分阶段实现**：先实现基础通信，再添加复杂功能
3. **充分测试**：重点测试前后端通信的稳定性

这个混合架构方案将让您的项目在技术先进性和用户体验方面都达到专业水准！
