# ã€Šæ—¶å…‰ä¿¡ç‰©ã€‹å¿«é€Ÿä¸Šæ‰‹æŒ‡å—

## ğŸš€ ç¯å¢ƒæ­å»ºï¼ˆ5åˆ†é’Ÿå¿«é€Ÿå¼€å§‹ï¼‰

### åç«¯ç¯å¢ƒï¼ˆC++ï¼‰
```bash
# 1. å®‰è£… vcpkgï¼ˆå¦‚æœè¿˜æ²¡æœ‰ï¼‰
git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg
./bootstrap-vcpkg.sh  # Linux/Mac
./bootstrap-vcpkg.bat  # Windows

# 2. å®‰è£…ä¾èµ–åŒ…
./vcpkg install nlohmann-json websocketpp sfml

# 3. åˆ›å»ºé¡¹ç›®ç›®å½•
mkdir TimeArtifacts
cd TimeArtifacts
mkdir backend frontend shared
```

### å‰ç«¯ç¯å¢ƒï¼ˆWebï¼‰
```bash
# è¿›å…¥å‰ç«¯ç›®å½•
cd frontend

# åˆå§‹åŒ– Node.js é¡¹ç›®
npm init -y

# å®‰è£…å¼€å‘ä¾èµ–ï¼ˆå¯é€‰ï¼Œç”¨äºå¢å¼ºå¼€å‘ä½“éªŒï¼‰
npm install --save-dev vite typescript @types/node

# åˆ›å»ºåŸºç¡€æ–‡ä»¶ç»“æ„
mkdir css js components assets
touch index.html css/main.css js/main.js js/gameClient.js
```

---

## ğŸ’» å¿«é€ŸåŸå‹ä»£ç 

### 1. åç«¯WebSocketæœåŠ¡å™¨ï¼ˆbackend/src/main.cppï¼‰
```cpp
#include <websocketpp/config/asio_no_tls.hpp>
#include <websocketpp/server.hpp>
#include <nlohmann/json.hpp>
#include <iostream>
#include <thread>

typedef websocketpp::server<websocketpp::config::asio> server;

class GameServer {
private:
    server wsServer;
    std::thread serverThread;
    
public:
    GameServer() {
        // è®¾ç½®æ—¥å¿—çº§åˆ«
        wsServer.set_access_channels(websocketpp::log::alevel::all);
        wsServer.clear_access_channels(websocketpp::log::alevel::frame_payload);
        
        // åˆå§‹åŒ– ASIO
        wsServer.init_asio();
        
        // è®¾ç½®æ¶ˆæ¯å¤„ç†å™¨
        wsServer.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {
            this->handleMessage(hdl, msg);
        });
        
        // è®¾ç½®è¿æ¥å¤„ç†å™¨
        wsServer.set_open_handler([this](websocketpp::connection_hdl hdl) {
            std::cout << "æ–°å®¢æˆ·ç«¯è¿æ¥" << std::endl;
            this->sendWelcomeMessage(hdl);
        });
    }
    
    void start(uint16_t port = 8080) {
        wsServer.listen(port);
        wsServer.start_accept();
        
        std::cout << "æ¸¸æˆæœåŠ¡å™¨å¯åŠ¨åœ¨ç«¯å£: " << port << std::endl;
        
        // åœ¨å•ç‹¬çº¿ç¨‹è¿è¡ŒæœåŠ¡å™¨
        serverThread = std::thread([this]() {
            wsServer.run();
        });
    }
    
    void stop() {
        wsServer.stop();
        if (serverThread.joinable()) {
            serverThread.join();
        }
    }
    
private:
    void handleMessage(websocketpp::connection_hdl hdl, server::message_ptr msg) {
        try {
            nlohmann::json request = nlohmann::json::parse(msg->get_payload());
            nlohmann::json response;
            
            std::string action = request["action"];
            std::cout << "æ”¶åˆ°å‘½ä»¤: " << action << std::endl;
            
            if (action == "move") {
                response = handleMove(request["data"]);
            } else if (action == "examine") {
                response = handleExamine(request["data"]);
            } else if (action == "talk") {
                response = handleTalk(request["data"]);
            } else {
                response = createErrorResponse("æœªçŸ¥å‘½ä»¤: " + action);
            }
            
            wsServer.send(hdl, response.dump(), websocketpp::frame::opcode::text);
            
        } catch (const std::exception& e) {
            std::cout << "å¤„ç†æ¶ˆæ¯æ—¶å‡ºé”™: " << e.what() << std::endl;
            nlohmann::json error = createErrorResponse("æ¶ˆæ¯å¤„ç†é”™è¯¯");
            wsServer.send(hdl, error.dump(), websocketpp::frame::opcode::text);
        }
    }
    
    void sendWelcomeMessage(websocketpp::connection_hdl hdl) {
        nlohmann::json welcome = {
            {"type", "gameState"},
            {"data", {
                {"currentLocation", "bookstore"},
                {"description", "æ¬¢è¿æ¥åˆ°æ—¶å…‰ä¿¡ç‰©çš„ä¸–ç•Œ..."},
                {"playerAttributes", {
                    {"observation", 1},
                    {"communication", 1},
                    {"action", 1},
                    {"empathy", 1}
                }},
                {"availableActions", nlohmann::json::array({
                    "examine_bookshelf",
                    "talk_to_owner",
                    "look_around"
                })}
            }}
        };
        
        wsServer.send(hdl, welcome.dump(), websocketpp::frame::opcode::text);
    }
    
    nlohmann::json handleMove(const nlohmann::json& data) {
        std::string direction = data["direction"];
        
        return {
            {"type", "locationChange"},
            {"data", {
                {"newLocation", "old_street"},
                {"description", "ä½ èµ°åˆ°äº†å¤è€çš„è¡—é“ä¸Šï¼ŒçŸ³æ¿è·¯åœ¨è„šä¸‹å‘å‡ºè½»å“..."},
                {"availableActions", nlohmann::json::array({
                    "examine_street_lamp",
                    "enter_bookstore",
                    "walk_to_harbor"
                })}
            }}
        };
    }
    
    nlohmann::json handleExamine(const nlohmann::json& data) {
        std::string target = data["target"];
        
        return {
            {"type", "examination"},
            {"data", {
                {"target", target},
                {"description", "ä»”ç»†è§‚å¯Ÿåï¼Œä½ å‘ç°äº†ä¸€äº›æœ‰è¶£çš„ç»†èŠ‚..."},
                {"attributeGain", {
                    {"observation", 1}
                }},
                {"newInsight", "bookstore_secret"}
            }}
        };
    }
    
    nlohmann::json handleTalk(const nlohmann::json& data) {
        return {
            {"type", "dialogue"},
            {"data", {
                {"speaker", "ä¹¦åº—è€æ¿"},
                {"text", "æ¬¢è¿æ¥åˆ°æ—¶å…‰è§’è½ï¼Œå¹´è½»äººã€‚ä½ çœ‹èµ·æ¥åƒæ˜¯åœ¨å¯»æ‰¾ä»€ä¹ˆç‰¹åˆ«çš„ä¸œè¥¿ã€‚"},
                {"options", nlohmann::json::array({
                    {
                        {"id", "option1"},
                        {"text", "æˆ‘åœ¨å¯»æ‰¾ä¸€äº›æ—§ç‰©ä»¶ï¼Œå…³äºè¿™ä¸ªåŸå¸‚è¿‡å»çš„è®°å¿†ã€‚"}
                    },
                    {
                        {"id", "option2"},
                        {"text", "[è§‚å¯Ÿ] æ³¨æ„åˆ°ä»–çœ¼ä¸­çš„å¿§ä¼¤ã€‚"},
                        {"requirement", "observation >= 3"}
                    }
                })}
            }}
        };
    }
    
    nlohmann::json createErrorResponse(const std::string& message) {
        return {
            {"type", "error"},
            {"message", message}
        };
    }
};

int main() {
    GameServer server;
    server.start(8080);
    
    std::cout << "æŒ‰ Enter é”®é€€å‡º..." << std::endl;
    std::cin.get();
    
    server.stop();
    return 0;
}
```

### 2. å‰ç«¯æ¸¸æˆå®¢æˆ·ç«¯ï¼ˆfrontend/js/gameClient.jsï¼‰
```javascript
class GameClient {
    constructor() {
        this.ws = null;
        this.gameState = {};
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
    }
    
    connect(url = 'ws://localhost:8080') {
        try {
            this.ws = new WebSocket(url);
            this.setupEventHandlers();
        } catch (error) {
            console.error('è¿æ¥å¤±è´¥:', error);
            this.handleConnectionError();
        }
    }
    
    setupEventHandlers() {
        this.ws.onopen = () => {
            console.log('å·²è¿æ¥åˆ°æ¸¸æˆæœåŠ¡å™¨');
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.updateConnectionStatus('å·²è¿æ¥', 'success');
        };
        
        this.ws.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                this.handleGameMessage(message);
            } catch (error) {
                console.error('è§£ææ¶ˆæ¯å¤±è´¥:', error);
            }
        };
        
        this.ws.onclose = () => {
            console.log('ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥');
            this.isConnected = false;
            this.updateConnectionStatus('è¿æ¥æ–­å¼€', 'error');
            this.attemptReconnect();
        };
        
        this.ws.onerror = (error) => {
            console.error('WebSocketé”™è¯¯:', error);
            this.handleConnectionError();
        };
    }
    
    handleGameMessage(message) {
        console.log('æ”¶åˆ°æ¸¸æˆæ¶ˆæ¯:', message);
        
        switch (message.type) {
            case 'gameState':
                this.updateGameState(message.data);
                break;
            case 'dialogue':
                this.showDialogue(message.data);
                break;
            case 'locationChange':
                this.updateLocation(message.data);
                break;
            case 'examination':
                this.showExaminationResult(message.data);
                break;
            case 'error':
                this.showError(message.message);
                break;
            default:
                console.warn('æœªçŸ¥æ¶ˆæ¯ç±»å‹:', message.type);
        }
    }
    
    sendCommand(action, data = {}) {
        if (!this.isConnected) {
            this.showError('æœªè¿æ¥åˆ°æœåŠ¡å™¨');
            return;
        }
        
        const command = {
            action: action,
            data: data,
            timestamp: Date.now()
        };
        
        console.log('å‘é€å‘½ä»¤:', command);
        this.ws.send(JSON.stringify(command));
    }
    
    updateGameState(data) {
        this.gameState = { ...this.gameState, ...data };
        
        // æ›´æ–°UI
        this.updateLocationDisplay(data.currentLocation, data.description);
        this.updatePlayerAttributes(data.playerAttributes);
        this.updateAvailableActions(data.availableActions);
    }
    
    updateLocationDisplay(location, description) {
        const locationHeader = document.getElementById('location-header');
        const sceneDescription = document.getElementById('scene-description');
        
        if (locationHeader) {
            locationHeader.textContent = this.getLocationDisplayName(location);
        }
        
        if (sceneDescription) {
            // ä½¿ç”¨æ‰“å­—æœºæ•ˆæœæ˜¾ç¤ºæè¿°
            this.typewriterText(sceneDescription, description);
        }
    }
    
    updatePlayerAttributes(attributes) {
        const attributesPanel = document.getElementById('player-attributes');
        if (!attributesPanel || !attributes) return;
        
        attributesPanel.innerHTML = '<h3>å±æ€§</h3>';
        
        const attributeNames = {
            'observation': 'è§‚å¯ŸåŠ›',
            'communication': 'æ²Ÿé€šåŠ›',
            'action': 'è¡ŒåŠ¨åŠ›',
            'empathy': 'å…±æƒ…å€¼'
        };
        
        for (const [key, value] of Object.entries(attributes)) {
            const attributeDiv = document.createElement('div');
            attributeDiv.className = 'attribute-item';
            attributeDiv.innerHTML = `
                <span class="attribute-name">${attributeNames[key] || key}:</span>
                <span class="attribute-value">${value}</span>
                <div class="attribute-bar">
                    <div class="attribute-fill" style="width: ${Math.min(value * 20, 100)}%"></div>
                </div>
            `;
            attributesPanel.appendChild(attributeDiv);
        }
    }
    
    updateAvailableActions(actions) {
        const actionsContainer = document.getElementById('available-actions');
        if (!actionsContainer || !actions) return;
        
        actionsContainer.innerHTML = '<h3>å¯ç”¨æ“ä½œ</h3>';
        
        actions.forEach(action => {
            const button = document.createElement('button');
            button.className = 'action-button';
            button.textContent = this.getActionDisplayName(action);
            button.onclick = () => this.executeAction(action);
            actionsContainer.appendChild(button);
        });
    }
    
    showDialogue(data) {
        const dialoguePanel = document.getElementById('dialogue-panel');
        const speakerName = document.getElementById('speaker-name');
        const dialogueText = document.getElementById('dialogue-text');
        const dialogueOptions = document.getElementById('dialogue-options');
        
        if (speakerName) speakerName.textContent = data.speaker;
        if (dialogueText) this.typewriterText(dialogueText, data.text);
        
        if (dialogueOptions && data.options) {
            dialogueOptions.innerHTML = '';
            data.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'dialogue-option';
                button.textContent = `${index + 1}. ${option.text}`;
                button.onclick = () => this.selectDialogueOption(option.id);
                dialogueOptions.appendChild(button);
            });
        }
        
        dialoguePanel.classList.remove('hidden');
    }
    
    async typewriterText(element, text, speed = 30) {
        element.textContent = '';
        element.classList.add('typing');
        
        for (let i = 0; i < text.length; i++) {
            element.textContent += text.charAt(i);
            await new Promise(resolve => setTimeout(resolve, speed));
        }
        
        element.classList.remove('typing');
    }
    
    executeAction(action) {
        switch (action) {
            case 'examine_bookshelf':
                this.sendCommand('examine', { target: 'bookshelf' });
                break;
            case 'talk_to_owner':
                this.sendCommand('talk', { target: 'owner' });
                break;
            case 'look_around':
                this.sendCommand('examine', { target: 'room' });
                break;
            default:
                this.sendCommand('action', { type: action });
        }
    }
    
    selectDialogueOption(optionId) {
        this.sendCommand('dialogue_choice', { optionId: optionId });
        document.getElementById('dialogue-panel').classList.add('hidden');
    }
    
    getLocationDisplayName(location) {
        const locationNames = {
            'bookstore': 'æ—¶å…‰è§’è½ä¹¦åº—',
            'old_street': 'å¤è€è¡—é“',
            'harbor': 'æ—§æ¸¯ç å¤´'
        };
        return locationNames[location] || location;
    }
    
    getActionDisplayName(action) {
        const actionNames = {
            'examine_bookshelf': 'æ£€æŸ¥ä¹¦æ¶',
            'talk_to_owner': 'ä¸åº—ä¸»äº¤è°ˆ',
            'look_around': 'ç¯é¡¾å››å‘¨',
            'examine_street_lamp': 'æŸ¥çœ‹è·¯ç¯',
            'enter_bookstore': 'è¿›å…¥ä¹¦åº—',
            'walk_to_harbor': 'å‰å¾€æ¸¯å£'
        };
        return actionNames[action] || action;
    }
    
    showError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = message;
        document.body.appendChild(errorDiv);
        
        setTimeout(() => {
            errorDiv.remove();
        }, 3000);
    }
    
    updateConnectionStatus(status, type) {
        const statusElement = document.getElementById('connection-status');
        if (statusElement) {
            statusElement.textContent = status;
            statusElement.className = `connection-status ${type}`;
        }
    }
    
    attemptReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            console.log(`å°è¯•é‡è¿... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
            
            setTimeout(() => {
                this.connect();
            }, 2000 * this.reconnectAttempts);
        } else {
            console.error('é‡è¿å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢');
            this.updateConnectionStatus('è¿æ¥å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢', 'error');
        }
    }
    
    handleConnectionError() {
        this.updateConnectionStatus('è¿æ¥é”™è¯¯', 'error');
    }
}

// å¯¼å‡ºç±»ä»¥ä¾›å…¶ä»–æ¨¡å—ä½¿ç”¨
window.GameClient = GameClient;
```

### 3. åŸºç¡€HTMLç•Œé¢ï¼ˆfrontend/index.htmlï¼‰
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ—¶å…‰ä¿¡ç‰© - Time Artifacts</title>
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
    <div id="game-container">
        <!-- è¿æ¥çŠ¶æ€æŒ‡ç¤ºå™¨ -->
        <div id="connection-status" class="connection-status">è¿æ¥ä¸­...</div>
        
        <!-- æ¸¸æˆä¸»ä½“åŒºåŸŸ -->
        <div class="game-layout">
            <!-- ä¸»è¦æ•…äº‹åŒºåŸŸ -->
            <div id="story-panel" class="panel main-panel">
                <div id="location-header" class="location-header">æ—¶å…‰è§’è½ä¹¦åº—</div>
                <div id="scene-description" class="scene-description">
                    æ­£åœ¨è¿æ¥æ¸¸æˆä¸–ç•Œ...
                </div>
                <div id="story-content" class="story-content"></div>
            </div>
            
            <!-- ä¾§è¾¹æ  -->
            <div class="sidebar">
                <!-- ç©å®¶å±æ€§é¢æ¿ -->
                <div id="player-attributes" class="panel attributes-panel">
                    <h3>å±æ€§</h3>
                    <div class="loading">åŠ è½½ä¸­...</div>
                </div>
                
                <!-- æ“ä½œé¢æ¿ -->
                <div id="available-actions" class="panel actions-panel">
                    <h3>å¯ç”¨æ“ä½œ</h3>
                    <div class="loading">åŠ è½½ä¸­...</div>
                </div>
                
                <!-- ä¸»é¢˜åˆ‡æ¢ -->
                <div class="panel theme-panel">
                    <h3>ä¸»é¢˜</h3>
                    <select id="theme-selector">
                        <option value="default">é»˜è®¤</option>
                        <option value="vintage">æ€€æ—§</option>
                        <option value="dark">æš—é»‘</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- å¯¹è¯é¢æ¿ï¼ˆæ‚¬æµ®æ˜¾ç¤ºï¼‰ -->
        <div id="dialogue-panel" class="panel dialogue-panel hidden">
            <div id="speaker-name" class="speaker-name"></div>
            <div id="dialogue-text" class="dialogue-text"></div>
            <div id="dialogue-options" class="dialogue-options"></div>
        </div>
    </div>
    
    <!-- é”™è¯¯æç¤ºåŒºåŸŸ -->
    <div id="error-container"></div>
    
    <!-- è„šæœ¬æ–‡ä»¶ -->
    <script src="js/gameClient.js"></script>
    <script src="js/main.js"></script>
</body>
</html>
```

### 4. ä¸»ç¨‹åºåˆå§‹åŒ–ï¼ˆfrontend/js/main.jsï¼‰
```javascript
// å…¨å±€æ¸¸æˆå®¢æˆ·ç«¯å®ä¾‹
let gameClient;

// é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
document.addEventListener('DOMContentLoaded', function() {
    console.log('æ—¶å…‰ä¿¡ç‰© - æ¸¸æˆå®¢æˆ·ç«¯å¯åŠ¨');
    
    // åˆ›å»ºæ¸¸æˆå®¢æˆ·ç«¯
    gameClient = new GameClient();
    
    // è¿æ¥åˆ°æ¸¸æˆæœåŠ¡å™¨
    gameClient.connect('ws://localhost:8080');
    
    // è®¾ç½®ä¸»é¢˜åˆ‡æ¢
    setupThemeSelector();
    
    // è®¾ç½®é”®ç›˜å¿«æ·é”®
    setupKeyboardShortcuts();
    
    console.log('å®¢æˆ·ç«¯åˆå§‹åŒ–å®Œæˆ');
});

function setupThemeSelector() {
    const themeSelector = document.getElementById('theme-selector');
    
    // åŠ è½½ä¿å­˜çš„ä¸»é¢˜
    const savedTheme = localStorage.getItem('gameTheme') || 'default';
    themeSelector.value = savedTheme;
    applyTheme(savedTheme);
    
    // ç›‘å¬ä¸»é¢˜åˆ‡æ¢
    themeSelector.addEventListener('change', function() {
        const selectedTheme = this.value;
        applyTheme(selectedTheme);
        localStorage.setItem('gameTheme', selectedTheme);
    });
}

function applyTheme(themeName) {
    document.documentElement.setAttribute('data-theme', themeName);
    console.log('åº”ç”¨ä¸»é¢˜:', themeName);
}

function setupKeyboardShortcuts() {
    document.addEventListener('keydown', function(event) {
        // ESCé”®å…³é—­å¯¹è¯æ¡†
        if (event.key === 'Escape') {
            const dialoguePanel = document.getElementById('dialogue-panel');
            if (dialoguePanel && !dialoguePanel.classList.contains('hidden')) {
                dialoguePanel.classList.add('hidden');
            }
        }
        
        // æ•°å­—é”®é€‰æ‹©å¯¹è¯é€‰é¡¹
        if (event.key >= '1' && event.key <= '9') {
            const dialogueOptions = document.querySelectorAll('.dialogue-option');
            const optionIndex = parseInt(event.key) - 1;
            if (dialogueOptions[optionIndex]) {
                dialogueOptions[optionIndex].click();
            }
        }
        
        // Ré”®é‡æ–°è¿æ¥
        if (event.key === 'r' || event.key === 'R') {
            if (event.ctrlKey && !gameClient.isConnected) {
                console.log('æ‰‹åŠ¨é‡æ–°è¿æ¥...');
                gameClient.connect();
            }
        }
    });
}

// çª—å£å…³é—­å‰æ¸…ç†
window.addEventListener('beforeunload', function() {
    if (gameClient && gameClient.ws) {
        gameClient.ws.close();
    }
});

// é”™è¯¯å¤„ç†
window.addEventListener('error', function(event) {
    console.error('å…¨å±€é”™è¯¯:', event.error);
});
```

---

## ğŸ¨ å¿«é€Ÿæ ·å¼ï¼ˆfrontend/css/main.cssï¼‰
```css
/* åŸºç¡€å˜é‡ */
:root {
    --bg-primary: #1a1a1a;
    --bg-secondary: #2d2d2d;
    --bg-panel: #333333;
    --text-primary: #e0e0e0;
    --text-secondary: #b0b0b0;
    --accent-color: #d4af37;
    --border-color: #404040;
    --success-color: #4caf50;
    --error-color: #f44336;
    --warning-color: #ff9800;
}

/* ä¸»é¢˜å˜é‡ */
[data-theme="vintage"] {
    --bg-primary: #2c1810;
    --bg-secondary: #3d241a;
    --bg-panel: #4a2f20;
    --text-primary: #f4e4c1;
    --text-secondary: #d4c4a0;
    --accent-color: #cd853f;
    --border-color: #5d4037;
}

[data-theme="dark"] {
    --bg-primary: #0a0a0a;
    --bg-secondary: #1a1a1a;
    --bg-panel: #222222;
    --text-primary: #ffffff;
    --text-secondary: #cccccc;
    --accent-color: #00bcd4;
    --border-color: #333333;
}

/* åŸºç¡€æ ·å¼ */
* {
    box-sizing: border-box;
}

body {
    margin: 0;
    padding: 0;
    font-family: 'Georgia', serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    line-height: 1.6;
    overflow-x: hidden;
}

/* æ¸¸æˆå®¹å™¨ */
#game-container {
    height: 100vh;
    display: flex;
    flex-direction: column;
}

/* è¿æ¥çŠ¶æ€ */
.connection-status {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    z-index: 1000;
}

.connection-status.success {
    background: var(--success-color);
    color: white;
}

.connection-status.error {
    background: var(--error-color);
    color: white;
}

/* æ¸¸æˆå¸ƒå±€ */
.game-layout {
    display: flex;
    flex: 1;
    gap: 10px;
    padding: 10px;
}

/* é¢æ¿æ ·å¼ */
.panel {
    background: var(--bg-panel);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
}

/* ä¸»é¢æ¿ */
.main-panel {
    flex: 2;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    max-height: calc(100vh - 40px);
}

/* ä¾§è¾¹æ  */
.sidebar {
    flex: 0 0 300px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

/* ä½ç½®æ ‡é¢˜ */
.location-header {
    font-size: 24px;
    font-weight: bold;
    color: var(--accent-color);
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 2px solid var(--accent-color);
    padding-bottom: 10px;
}

/* åœºæ™¯æè¿° */
.scene-description {
    font-size: 16px;
    margin-bottom: 20px;
    padding: 15px;
    background: var(--bg-secondary);
    border-radius: 6px;
    border-left: 4px solid var(--accent-color);
}

/* æ‰“å­—æœºæ•ˆæœ */
.typing {
    border-right: 2px solid var(--accent-color);
    animation: blink-caret 1s step-end infinite;
}

@keyframes blink-caret {
    from, to { border-color: transparent; }
    50% { border-color: var(--accent-color); }
}

/* å±æ€§æ˜¾ç¤º */
.attribute-item {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
    gap: 10px;
}

.attribute-name {
    flex: 0 0 80px;
    font-weight: bold;
}

.attribute-value {
    flex: 0 0 30px;
    text-align: center;
    color: var(--accent-color);
    font-weight: bold;
}

.attribute-bar {
    flex: 1;
    height: 8px;
    background: var(--border-color);
    border-radius: 4px;
    overflow: hidden;
}

.attribute-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent-color), #ffd700);
    transition: width 0.3s ease;
}

/* æŒ‰é’®æ ·å¼ */
.action-button, .dialogue-option {
    display: block;
    width: 100%;
    margin-bottom: 8px;
    padding: 12px;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.action-button:hover, .dialogue-option:hover {
    background: var(--accent-color);
    color: var(--bg-primary);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

/* å¯¹è¯é¢æ¿ */
.dialogue-panel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 80%;
    max-width: 600px;
    z-index: 1000;
    border: 2px solid var(--accent-color);
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}

.dialogue-panel.hidden {
    display: none;
}

.speaker-name {
    font-size: 18px;
    font-weight: bold;
    color: var(--accent-color);
    margin-bottom: 10px;
}

.dialogue-text {
    font-size: 16px;
    margin-bottom: 20px;
    line-height: 1.8;
}

/* ä¸»é¢˜é€‰æ‹©å™¨ */
#theme-selector {
    width: 100%;
    padding: 8px;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    color: var(--text-primary);
    font-family: inherit;
}

/* é”™è¯¯æ¶ˆæ¯ */
.error-message {
    position: fixed;
    top: 50px;
    right: 20px;
    padding: 10px 15px;
    background: var(--error-color);
    color: white;
    border-radius: 6px;
    font-weight: bold;
    z-index: 1000;
    animation: slideIn 0.3s ease;
}

@keyframes slideIn {
    from { transform: translateX(100%); }
    to { transform: translateX(0); }
}

/* å“åº”å¼è®¾è®¡ */
@media (max-width: 768px) {
    .game-layout {
        flex-direction: column;
    }
    
    .sidebar {
        flex: none;
        flex-direction: row;
        overflow-x: auto;
    }
    
    .sidebar .panel {
        flex: 0 0 250px;
    }
    
    .dialogue-panel {
        width: 95%;
    }
}

/* åŠ è½½çŠ¶æ€ */
.loading {
    text-align: center;
    color: var(--text-secondary);
    font-style: italic;
}

/* é¡µé¢æ ‡é¢˜ */
h3 {
    margin-top: 0;
    color: var(--accent-color);
    font-size: 18px;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 8px;
}
```

---

## ğŸš€ è¿è¡ŒæŒ‡å—

### 1. å¯åŠ¨åç«¯æœåŠ¡å™¨
```bash
cd backend
mkdir build
cd build
cmake .. -DCMAKE_TOOLCHAIN_FILE=[vcpkgè·¯å¾„]/scripts/buildsystems/vcpkg.cmake
make
./TimeArtifacts
```

### 2. å¯åŠ¨å‰ç«¯ç•Œé¢
```bash
cd frontend
# æ–¹å¼1ï¼šä½¿ç”¨æœ¬åœ°HTTPæœåŠ¡å™¨
python -m http.server 3000

# æ–¹å¼2ï¼šä½¿ç”¨Node.jsï¼ˆå¦‚æœå®‰è£…äº†ï¼‰
npx serve .

# æ–¹å¼3ï¼šç›´æ¥ç”¨æµè§ˆå™¨æ‰“å¼€
# åœ¨æµè§ˆå™¨ä¸­æ‰“å¼€ index.html
```

### 3. æµ‹è¯•æ¸¸æˆ
1. æ‰“å¼€æµè§ˆå™¨è®¿é—® `http://localhost:3000`
2. ç¡®è®¤è¿æ¥çŠ¶æ€æ˜¾ç¤ºä¸º"å·²è¿æ¥"
3. å°è¯•ç‚¹å‡»å„ç§æ“ä½œæŒ‰é’®
4. æµ‹è¯•å¯¹è¯ç³»ç»Ÿ
5. åˆ‡æ¢ä¸åŒä¸»é¢˜

è¿™ä¸ªå¿«é€ŸåŸå‹è®©æ‚¨åœ¨30åˆ†é’Ÿå†…çœ‹åˆ°å®Œæ•´çš„å‰åç«¯é€šä¿¡æ•ˆæœï¼ğŸ‰
