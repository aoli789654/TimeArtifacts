# 《时光信物》快速上手指南

## 🚀 环境搭建（5分钟快速开始）

### 后端环境（C++）
```bash
# 1. 安装 vcpkg（如果还没有）
git clone https://github.com/Microsoft/vcpkg.git
cd vcpkg
./bootstrap-vcpkg.sh  # Linux/Mac
./bootstrap-vcpkg.bat  # Windows

# 2. 安装依赖包
./vcpkg install nlohmann-json websocketpp sfml

# 3. 创建项目目录
mkdir TimeArtifacts
cd TimeArtifacts
mkdir backend frontend shared
```

### 前端环境（Web）
```bash
# 进入前端目录
cd frontend

# 初始化 Node.js 项目
npm init -y

# 安装开发依赖（可选，用于增强开发体验）
npm install --save-dev vite typescript @types/node

# 创建基础文件结构
mkdir css js components assets
touch index.html css/main.css js/main.js js/gameClient.js
```

---

## 💻 快速原型代码

### 1. 后端WebSocket服务器（backend/src/main.cpp）
```cpp
#include <websocketpp/config/asio_no_tls.hpp>
#include <websocketpp/server.hpp>
#include <nlohmann/json.hpp>
#include <iostream>
#include <thread>

typedef websocketpp::server<websocketpp::config::asio> server;

class GameServer {
private:
    server wsServer;
    std::thread serverThread;
    
public:
    GameServer() {
        // 设置日志级别
        wsServer.set_access_channels(websocketpp::log::alevel::all);
        wsServer.clear_access_channels(websocketpp::log::alevel::frame_payload);
        
        // 初始化 ASIO
        wsServer.init_asio();
        
        // 设置消息处理器
        wsServer.set_message_handler([this](websocketpp::connection_hdl hdl, server::message_ptr msg) {
            this->handleMessage(hdl, msg);
        });
        
        // 设置连接处理器
        wsServer.set_open_handler([this](websocketpp::connection_hdl hdl) {
            std::cout << "新客户端连接" << std::endl;
            this->sendWelcomeMessage(hdl);
        });
    }
    
    void start(uint16_t port = 8080) {
        wsServer.listen(port);
        wsServer.start_accept();
        
        std::cout << "游戏服务器启动在端口: " << port << std::endl;
        
        // 在单独线程运行服务器
        serverThread = std::thread([this]() {
            wsServer.run();
        });
    }
    
    void stop() {
        wsServer.stop();
        if (serverThread.joinable()) {
            serverThread.join();
        }
    }
    
private:
    void handleMessage(websocketpp::connection_hdl hdl, server::message_ptr msg) {
        try {
            nlohmann::json request = nlohmann::json::parse(msg->get_payload());
            nlohmann::json response;
            
            std::string action = request["action"];
            std::cout << "收到命令: " << action << std::endl;
            
            if (action == "move") {
                response = handleMove(request["data"]);
            } else if (action == "examine") {
                response = handleExamine(request["data"]);
            } else if (action == "talk") {
                response = handleTalk(request["data"]);
            } else {
                response = createErrorResponse("未知命令: " + action);
            }
            
            wsServer.send(hdl, response.dump(), websocketpp::frame::opcode::text);
            
        } catch (const std::exception& e) {
            std::cout << "处理消息时出错: " << e.what() << std::endl;
            nlohmann::json error = createErrorResponse("消息处理错误");
            wsServer.send(hdl, error.dump(), websocketpp::frame::opcode::text);
        }
    }
    
    void sendWelcomeMessage(websocketpp::connection_hdl hdl) {
        nlohmann::json welcome = {
            {"type", "gameState"},
            {"data", {
                {"currentLocation", "bookstore"},
                {"description", "欢迎来到时光信物的世界..."},
                {"playerAttributes", {
                    {"observation", 1},
                    {"communication", 1},
                    {"action", 1},
                    {"empathy", 1}
                }},
                {"availableActions", nlohmann::json::array({
                    "examine_bookshelf",
                    "talk_to_owner",
                    "look_around"
                })}
            }}
        };
        
        wsServer.send(hdl, welcome.dump(), websocketpp::frame::opcode::text);
    }
    
    nlohmann::json handleMove(const nlohmann::json& data) {
        std::string direction = data["direction"];
        
        return {
            {"type", "locationChange"},
            {"data", {
                {"newLocation", "old_street"},
                {"description", "你走到了古老的街道上，石板路在脚下发出轻响..."},
                {"availableActions", nlohmann::json::array({
                    "examine_street_lamp",
                    "enter_bookstore",
                    "walk_to_harbor"
                })}
            }}
        };
    }
    
    nlohmann::json handleExamine(const nlohmann::json& data) {
        std::string target = data["target"];
        
        return {
            {"type", "examination"},
            {"data", {
                {"target", target},
                {"description", "仔细观察后，你发现了一些有趣的细节..."},
                {"attributeGain", {
                    {"observation", 1}
                }},
                {"newInsight", "bookstore_secret"}
            }}
        };
    }
    
    nlohmann::json handleTalk(const nlohmann::json& data) {
        return {
            {"type", "dialogue"},
            {"data", {
                {"speaker", "书店老板"},
                {"text", "欢迎来到时光角落，年轻人。你看起来像是在寻找什么特别的东西。"},
                {"options", nlohmann::json::array({
                    {
                        {"id", "option1"},
                        {"text", "我在寻找一些旧物件，关于这个城市过去的记忆。"}
                    },
                    {
                        {"id", "option2"},
                        {"text", "[观察] 注意到他眼中的忧伤。"},
                        {"requirement", "observation >= 3"}
                    }
                })}
            }}
        };
    }
    
    nlohmann::json createErrorResponse(const std::string& message) {
        return {
            {"type", "error"},
            {"message", message}
        };
    }
};

int main() {
    GameServer server;
    server.start(8080);
    
    std::cout << "按 Enter 键退出..." << std::endl;
    std::cin.get();
    
    server.stop();
    return 0;
}
```

### 2. 前端游戏客户端（frontend/js/gameClient.js）
```javascript
class GameClient {
    constructor() {
        this.ws = null;
        this.gameState = {};
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 5;
    }
    
    connect(url = 'ws://localhost:8080') {
        try {
            this.ws = new WebSocket(url);
            this.setupEventHandlers();
        } catch (error) {
            console.error('连接失败:', error);
            this.handleConnectionError();
        }
    }
    
    setupEventHandlers() {
        this.ws.onopen = () => {
            console.log('已连接到游戏服务器');
            this.isConnected = true;
            this.reconnectAttempts = 0;
            this.updateConnectionStatus('已连接', 'success');
        };
        
        this.ws.onmessage = (event) => {
            try {
                const message = JSON.parse(event.data);
                this.handleGameMessage(message);
            } catch (error) {
                console.error('解析消息失败:', error);
            }
        };
        
        this.ws.onclose = () => {
            console.log('与服务器断开连接');
            this.isConnected = false;
            this.updateConnectionStatus('连接断开', 'error');
            this.attemptReconnect();
        };
        
        this.ws.onerror = (error) => {
            console.error('WebSocket错误:', error);
            this.handleConnectionError();
        };
    }
    
    handleGameMessage(message) {
        console.log('收到游戏消息:', message);
        
        switch (message.type) {
            case 'gameState':
                this.updateGameState(message.data);
                break;
            case 'dialogue':
                this.showDialogue(message.data);
                break;
            case 'locationChange':
                this.updateLocation(message.data);
                break;
            case 'examination':
                this.showExaminationResult(message.data);
                break;
            case 'error':
                this.showError(message.message);
                break;
            default:
                console.warn('未知消息类型:', message.type);
        }
    }
    
    sendCommand(action, data = {}) {
        if (!this.isConnected) {
            this.showError('未连接到服务器');
            return;
        }
        
        const command = {
            action: action,
            data: data,
            timestamp: Date.now()
        };
        
        console.log('发送命令:', command);
        this.ws.send(JSON.stringify(command));
    }
    
    updateGameState(data) {
        this.gameState = { ...this.gameState, ...data };
        
        // 更新UI
        this.updateLocationDisplay(data.currentLocation, data.description);
        this.updatePlayerAttributes(data.playerAttributes);
        this.updateAvailableActions(data.availableActions);
    }
    
    updateLocationDisplay(location, description) {
        const locationHeader = document.getElementById('location-header');
        const sceneDescription = document.getElementById('scene-description');
        
        if (locationHeader) {
            locationHeader.textContent = this.getLocationDisplayName(location);
        }
        
        if (sceneDescription) {
            // 使用打字机效果显示描述
            this.typewriterText(sceneDescription, description);
        }
    }
    
    updatePlayerAttributes(attributes) {
        const attributesPanel = document.getElementById('player-attributes');
        if (!attributesPanel || !attributes) return;
        
        attributesPanel.innerHTML = '<h3>属性</h3>';
        
        const attributeNames = {
            'observation': '观察力',
            'communication': '沟通力',
            'action': '行动力',
            'empathy': '共情值'
        };
        
        for (const [key, value] of Object.entries(attributes)) {
            const attributeDiv = document.createElement('div');
            attributeDiv.className = 'attribute-item';
            attributeDiv.innerHTML = `
                <span class="attribute-name">${attributeNames[key] || key}:</span>
                <span class="attribute-value">${value}</span>
                <div class="attribute-bar">
                    <div class="attribute-fill" style="width: ${Math.min(value * 20, 100)}%"></div>
                </div>
            `;
            attributesPanel.appendChild(attributeDiv);
        }
    }
    
    updateAvailableActions(actions) {
        const actionsContainer = document.getElementById('available-actions');
        if (!actionsContainer || !actions) return;
        
        actionsContainer.innerHTML = '<h3>可用操作</h3>';
        
        actions.forEach(action => {
            const button = document.createElement('button');
            button.className = 'action-button';
            button.textContent = this.getActionDisplayName(action);
            button.onclick = () => this.executeAction(action);
            actionsContainer.appendChild(button);
        });
    }
    
    showDialogue(data) {
        const dialoguePanel = document.getElementById('dialogue-panel');
        const speakerName = document.getElementById('speaker-name');
        const dialogueText = document.getElementById('dialogue-text');
        const dialogueOptions = document.getElementById('dialogue-options');
        
        if (speakerName) speakerName.textContent = data.speaker;
        if (dialogueText) this.typewriterText(dialogueText, data.text);
        
        if (dialogueOptions && data.options) {
            dialogueOptions.innerHTML = '';
            data.options.forEach((option, index) => {
                const button = document.createElement('button');
                button.className = 'dialogue-option';
                button.textContent = `${index + 1}. ${option.text}`;
                button.onclick = () => this.selectDialogueOption(option.id);
                dialogueOptions.appendChild(button);
            });
        }
        
        dialoguePanel.classList.remove('hidden');
    }
    
    async typewriterText(element, text, speed = 30) {
        element.textContent = '';
        element.classList.add('typing');
        
        for (let i = 0; i < text.length; i++) {
            element.textContent += text.charAt(i);
            await new Promise(resolve => setTimeout(resolve, speed));
        }
        
        element.classList.remove('typing');
    }
    
    executeAction(action) {
        switch (action) {
            case 'examine_bookshelf':
                this.sendCommand('examine', { target: 'bookshelf' });
                break;
            case 'talk_to_owner':
                this.sendCommand('talk', { target: 'owner' });
                break;
            case 'look_around':
                this.sendCommand('examine', { target: 'room' });
                break;
            default:
                this.sendCommand('action', { type: action });
        }
    }
    
    selectDialogueOption(optionId) {
        this.sendCommand('dialogue_choice', { optionId: optionId });
        document.getElementById('dialogue-panel').classList.add('hidden');
    }
    
    getLocationDisplayName(location) {
        const locationNames = {
            'bookstore': '时光角落书店',
            'old_street': '古老街道',
            'harbor': '旧港码头'
        };
        return locationNames[location] || location;
    }
    
    getActionDisplayName(action) {
        const actionNames = {
            'examine_bookshelf': '检查书架',
            'talk_to_owner': '与店主交谈',
            'look_around': '环顾四周',
            'examine_street_lamp': '查看路灯',
            'enter_bookstore': '进入书店',
            'walk_to_harbor': '前往港口'
        };
        return actionNames[action] || action;
    }
    
    showError(message) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'error-message';
        errorDiv.textContent = message;
        document.body.appendChild(errorDiv);
        
        setTimeout(() => {
            errorDiv.remove();
        }, 3000);
    }
    
    updateConnectionStatus(status, type) {
        const statusElement = document.getElementById('connection-status');
        if (statusElement) {
            statusElement.textContent = status;
            statusElement.className = `connection-status ${type}`;
        }
    }
    
    attemptReconnect() {
        if (this.reconnectAttempts < this.maxReconnectAttempts) {
            this.reconnectAttempts++;
            console.log(`尝试重连... (${this.reconnectAttempts}/${this.maxReconnectAttempts})`);
            
            setTimeout(() => {
                this.connect();
            }, 2000 * this.reconnectAttempts);
        } else {
            console.error('重连失败，请刷新页面');
            this.updateConnectionStatus('连接失败，请刷新页面', 'error');
        }
    }
    
    handleConnectionError() {
        this.updateConnectionStatus('连接错误', 'error');
    }
}

// 导出类以供其他模块使用
window.GameClient = GameClient;
```

### 3. 基础HTML界面（frontend/index.html）
```html
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>时光信物 - Time Artifacts</title>
    <link rel="stylesheet" href="css/main.css">
</head>
<body>
    <div id="game-container">
        <!-- 连接状态指示器 -->
        <div id="connection-status" class="connection-status">连接中...</div>
        
        <!-- 游戏主体区域 -->
        <div class="game-layout">
            <!-- 主要故事区域 -->
            <div id="story-panel" class="panel main-panel">
                <div id="location-header" class="location-header">时光角落书店</div>
                <div id="scene-description" class="scene-description">
                    正在连接游戏世界...
                </div>
                <div id="story-content" class="story-content"></div>
            </div>
            
            <!-- 侧边栏 -->
            <div class="sidebar">
                <!-- 玩家属性面板 -->
                <div id="player-attributes" class="panel attributes-panel">
                    <h3>属性</h3>
                    <div class="loading">加载中...</div>
                </div>
                
                <!-- 操作面板 -->
                <div id="available-actions" class="panel actions-panel">
                    <h3>可用操作</h3>
                    <div class="loading">加载中...</div>
                </div>
                
                <!-- 主题切换 -->
                <div class="panel theme-panel">
                    <h3>主题</h3>
                    <select id="theme-selector">
                        <option value="default">默认</option>
                        <option value="vintage">怀旧</option>
                        <option value="dark">暗黑</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- 对话面板（悬浮显示） -->
        <div id="dialogue-panel" class="panel dialogue-panel hidden">
            <div id="speaker-name" class="speaker-name"></div>
            <div id="dialogue-text" class="dialogue-text"></div>
            <div id="dialogue-options" class="dialogue-options"></div>
        </div>
    </div>
    
    <!-- 错误提示区域 -->
    <div id="error-container"></div>
    
    <!-- 脚本文件 -->
    <script src="js/gameClient.js"></script>
    <script src="js/main.js"></script>
</body>
</html>
```

### 4. 主程序初始化（frontend/js/main.js）
```javascript
// 全局游戏客户端实例
let gameClient;

// 页面加载完成后初始化
document.addEventListener('DOMContentLoaded', function() {
    console.log('时光信物 - 游戏客户端启动');
    
    // 创建游戏客户端
    gameClient = new GameClient();
    
    // 连接到游戏服务器
    gameClient.connect('ws://localhost:8080');
    
    // 设置主题切换
    setupThemeSelector();
    
    // 设置键盘快捷键
    setupKeyboardShortcuts();
    
    console.log('客户端初始化完成');
});

function setupThemeSelector() {
    const themeSelector = document.getElementById('theme-selector');
    
    // 加载保存的主题
    const savedTheme = localStorage.getItem('gameTheme') || 'default';
    themeSelector.value = savedTheme;
    applyTheme(savedTheme);
    
    // 监听主题切换
    themeSelector.addEventListener('change', function() {
        const selectedTheme = this.value;
        applyTheme(selectedTheme);
        localStorage.setItem('gameTheme', selectedTheme);
    });
}

function applyTheme(themeName) {
    document.documentElement.setAttribute('data-theme', themeName);
    console.log('应用主题:', themeName);
}

function setupKeyboardShortcuts() {
    document.addEventListener('keydown', function(event) {
        // ESC键关闭对话框
        if (event.key === 'Escape') {
            const dialoguePanel = document.getElementById('dialogue-panel');
            if (dialoguePanel && !dialoguePanel.classList.contains('hidden')) {
                dialoguePanel.classList.add('hidden');
            }
        }
        
        // 数字键选择对话选项
        if (event.key >= '1' && event.key <= '9') {
            const dialogueOptions = document.querySelectorAll('.dialogue-option');
            const optionIndex = parseInt(event.key) - 1;
            if (dialogueOptions[optionIndex]) {
                dialogueOptions[optionIndex].click();
            }
        }
        
        // R键重新连接
        if (event.key === 'r' || event.key === 'R') {
            if (event.ctrlKey && !gameClient.isConnected) {
                console.log('手动重新连接...');
                gameClient.connect();
            }
        }
    });
}

// 窗口关闭前清理
window.addEventListener('beforeunload', function() {
    if (gameClient && gameClient.ws) {
        gameClient.ws.close();
    }
});

// 错误处理
window.addEventListener('error', function(event) {
    console.error('全局错误:', event.error);
});
```

---

## 🎨 快速样式（frontend/css/main.css）
```css
/* 基础变量 */
:root {
    --bg-primary: #1a1a1a;
    --bg-secondary: #2d2d2d;
    --bg-panel: #333333;
    --text-primary: #e0e0e0;
    --text-secondary: #b0b0b0;
    --accent-color: #d4af37;
    --border-color: #404040;
    --success-color: #4caf50;
    --error-color: #f44336;
    --warning-color: #ff9800;
}

/* 主题变量 */
[data-theme="vintage"] {
    --bg-primary: #2c1810;
    --bg-secondary: #3d241a;
    --bg-panel: #4a2f20;
    --text-primary: #f4e4c1;
    --text-secondary: #d4c4a0;
    --accent-color: #cd853f;
    --border-color: #5d4037;
}

[data-theme="dark"] {
    --bg-primary: #0a0a0a;
    --bg-secondary: #1a1a1a;
    --bg-panel: #222222;
    --text-primary: #ffffff;
    --text-secondary: #cccccc;
    --accent-color: #00bcd4;
    --border-color: #333333;
}

/* 基础样式 */
* {
    box-sizing: border-box;
}

body {
    margin: 0;
    padding: 0;
    font-family: 'Georgia', serif;
    background: var(--bg-primary);
    color: var(--text-primary);
    line-height: 1.6;
    overflow-x: hidden;
}

/* 游戏容器 */
#game-container {
    height: 100vh;
    display: flex;
    flex-direction: column;
}

/* 连接状态 */
.connection-status {
    position: fixed;
    top: 10px;
    right: 10px;
    padding: 5px 10px;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    z-index: 1000;
}

.connection-status.success {
    background: var(--success-color);
    color: white;
}

.connection-status.error {
    background: var(--error-color);
    color: white;
}

/* 游戏布局 */
.game-layout {
    display: flex;
    flex: 1;
    gap: 10px;
    padding: 10px;
}

/* 面板样式 */
.panel {
    background: var(--bg-panel);
    border: 1px solid var(--border-color);
    border-radius: 8px;
    padding: 20px;
    box-shadow: 0 2px 10px rgba(0,0,0,0.3);
}

/* 主面板 */
.main-panel {
    flex: 2;
    display: flex;
    flex-direction: column;
    overflow-y: auto;
    max-height: calc(100vh - 40px);
}

/* 侧边栏 */
.sidebar {
    flex: 0 0 300px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

/* 位置标题 */
.location-header {
    font-size: 24px;
    font-weight: bold;
    color: var(--accent-color);
    margin-bottom: 15px;
    text-align: center;
    border-bottom: 2px solid var(--accent-color);
    padding-bottom: 10px;
}

/* 场景描述 */
.scene-description {
    font-size: 16px;
    margin-bottom: 20px;
    padding: 15px;
    background: var(--bg-secondary);
    border-radius: 6px;
    border-left: 4px solid var(--accent-color);
}

/* 打字机效果 */
.typing {
    border-right: 2px solid var(--accent-color);
    animation: blink-caret 1s step-end infinite;
}

@keyframes blink-caret {
    from, to { border-color: transparent; }
    50% { border-color: var(--accent-color); }
}

/* 属性显示 */
.attribute-item {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
    gap: 10px;
}

.attribute-name {
    flex: 0 0 80px;
    font-weight: bold;
}

.attribute-value {
    flex: 0 0 30px;
    text-align: center;
    color: var(--accent-color);
    font-weight: bold;
}

.attribute-bar {
    flex: 1;
    height: 8px;
    background: var(--border-color);
    border-radius: 4px;
    overflow: hidden;
}

.attribute-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent-color), #ffd700);
    transition: width 0.3s ease;
}

/* 按钮样式 */
.action-button, .dialogue-option {
    display: block;
    width: 100%;
    margin-bottom: 8px;
    padding: 12px;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    color: var(--text-primary);
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
}

.action-button:hover, .dialogue-option:hover {
    background: var(--accent-color);
    color: var(--bg-primary);
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(0,0,0,0.2);
}

/* 对话面板 */
.dialogue-panel {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 80%;
    max-width: 600px;
    z-index: 1000;
    border: 2px solid var(--accent-color);
    box-shadow: 0 10px 30px rgba(0,0,0,0.5);
}

.dialogue-panel.hidden {
    display: none;
}

.speaker-name {
    font-size: 18px;
    font-weight: bold;
    color: var(--accent-color);
    margin-bottom: 10px;
}

.dialogue-text {
    font-size: 16px;
    margin-bottom: 20px;
    line-height: 1.8;
}

/* 主题选择器 */
#theme-selector {
    width: 100%;
    padding: 8px;
    background: var(--bg-secondary);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    color: var(--text-primary);
    font-family: inherit;
}

/* 错误消息 */
.error-message {
    position: fixed;
    top: 50px;
    right: 20px;
    padding: 10px 15px;
    background: var(--error-color);
    color: white;
    border-radius: 6px;
    font-weight: bold;
    z-index: 1000;
    animation: slideIn 0.3s ease;
}

@keyframes slideIn {
    from { transform: translateX(100%); }
    to { transform: translateX(0); }
}

/* 响应式设计 */
@media (max-width: 768px) {
    .game-layout {
        flex-direction: column;
    }
    
    .sidebar {
        flex: none;
        flex-direction: row;
        overflow-x: auto;
    }
    
    .sidebar .panel {
        flex: 0 0 250px;
    }
    
    .dialogue-panel {
        width: 95%;
    }
}

/* 加载状态 */
.loading {
    text-align: center;
    color: var(--text-secondary);
    font-style: italic;
}

/* 页面标题 */
h3 {
    margin-top: 0;
    color: var(--accent-color);
    font-size: 18px;
    border-bottom: 1px solid var(--border-color);
    padding-bottom: 8px;
}
```

---

## 🚀 运行指南

### 1. 启动后端服务器
```bash
cd backend
mkdir build
cd build
cmake .. -DCMAKE_TOOLCHAIN_FILE=[vcpkg路径]/scripts/buildsystems/vcpkg.cmake
make
./TimeArtifacts
```

### 2. 启动前端界面
```bash
cd frontend
# 方式1：使用本地HTTP服务器
python -m http.server 3000

# 方式2：使用Node.js（如果安装了）
npx serve .

# 方式3：直接用浏览器打开
# 在浏览器中打开 index.html
```

### 3. 测试游戏
1. 打开浏览器访问 `http://localhost:3000`
2. 确认连接状态显示为"已连接"
3. 尝试点击各种操作按钮
4. 测试对话系统
5. 切换不同主题

这个快速原型让您在30分钟内看到完整的前后端通信效果！🎉
